'''
Core datastructure of FMSignal

@author: duolu
'''


import numpy as np
import scipy.stats
import scipy.signal


import math
from math import sin
from math import cos
from math import atan2
from math import atan

import csv

from fmkit.utils import *



class FMSignal(object):
    '''
    Data structure representing a finger motion signal.
    
    Base class for the finger motion signal (both collected by the glove and 
    the leap motion controller). The finger motion signal is a time series  
    containing samples of physical states of the finger tip.
    
    The important components of a FMSignal are:
    
    l:     length of the time series (i.e., number of samples)
    d:     dimension of each sample (i.e., number of sensor axes)
    ts:    timestamps of each sample, as a l dimension vector
    data:  the actual data samples, as a l * d matrix
    stat:  the statistical features. See the stat_feature_extract_xxx() method.
    
    user_label:  the user that create this signal
    id_label:    the unique id that differ the content of the signal
    seq:         the sequence id in a batch when loaded from dataset
    
    Note that user_label, id_label, and seq are only used for printing 
    information for debugging. Use FMSignalDesc in dataset.py for obtaining
    the meta data of the signal. Typically, the signal file is named as
    "user_label_id_label_seq.txt" (or .csv, .npy). keep these three part helps
    us to quickly find which signal it is in the debugging.
    
    Note that this is the abstract class that only implements the common 
    attributs and methods. To construct the actual signal, use derived class
    such as FMSignalLeap or FMSignalGlove instead.
    
    See "The FMKit Dataset Format" document for more information.
    
    '''


    def __init__(self, length=-1, dimension=-1, ts=None, data=None, stat=None,
            user_label='', id_label='', seq=0):
        '''
        Default constructor, which essentially constructs nothing.
        '''

        self.l = length
        self.d = dimension
        self.ts = ts
        self.data = data
        self.stat = stat

        self.user_label = user_label
        self.id_label = id_label
        self.seq = seq
        
        # Here the user_label, id_label, and seq are just for prints.
        # Refer to FMSignalDesc in dataset.py if more information is needed.
        
    def load_from_file_raw(self, *args, **kargs):
        '''
        Load from raw text file generated by the data collection procedure.
        
        
        CAUTION: This method is not implemented in the base class.
        '''
        
        raise NotImplementedError(
            "Method load_from_file_raw() is NOT IMPLEMENTED in FMSignal!!!")
    
    def save_signal_to_file_csv(self, fn):
        '''
        Save the signal to CSV file. Each row is prefixed with the timestamp.
        '''
        
        array = np.concatenate((self.ts, self.data), axis=1)
        np.savetxt(fn, array, fmt='%.6f', delimiter=', ')

    def load_signal_from_file_csv(self, fn):
        '''
        Load the signal from a CSV file.
        '''

        array = np.loadtxt(fn, dtype=np.float32, delimiter=',')

        ts = array[:, 0:1]
        data = array[:, 1:]

        l = data.shape[0]
        d = data.shape[1]


        self.l = l
        self.d = d
        self.ts = ts
        self.data = data

    def save_stat_features_to_file_csv(self, fn):
        '''
        Save the statistical features to a CSV file.
        '''
        
        assert (self.stat is not None), 'The signal does not have stat.'
        shape = self.stat.shape
        array = self.stat.reshape((shape[0] * shape[1], shape[2]))
        np.savetxt(fn, array, fmt='%.6f', delimiter=', ')

    def load_stat_features_from_file_csv(self, fn):
        '''
        Load the statistical features from a CSV file.
        '''

        array = np.loadtxt(fn, dtype=np.float32, delimiter=',')
        shape = array.shape
        self.stat = array.reshape((shape[0] // 5, 5, self.d))
                
    def save_signal_to_file_binary(self, fn):
        '''
        Save the signal to a .npy file.
        '''
        
        array = np.concatenate((self.ts, self.data), axis=1)
        np.save(fn, array)
        
    def load_signal_from_file_binary(self, fn):
        '''
        Load the signal from a .npy file.
        '''
        
        array = np.load(fn)
        
        ts = array[:, 0:1]
        data = array[:, 1:]

        l = data.shape[0]
        d = data.shape[1]
        
        self.l = l
        self.d = d
        self.ts = ts
        self.data = data

    def save_stat_features_to_file_binary(self, fn):
        '''
        Save the statistical features to a .npy file.
        '''
        
        assert (self.stat is not None), 'The signal does not have stat.'
        np.save(fn, self.stat)

    def load_stat_features_from_file_binary(self, fn):
        '''
        Load the statistical features from a .npy file.
        '''

        self.stat = np.load(fn)
        
    def save_to_file(self, fn, mode, use_stat):
        '''
        General interface to save the signal object to files.
        '''

        if mode == 'csv':
            self.save_signal_to_file_csv(fn + ".csv")
            if use_stat:
                self.save_stat_features_to_file_csv(fn + "_ss.csv")
        elif mode == 'binary':
            # CAUTION: np.save() appends ".npy" postfix to the fn.
            self.save_signal_to_file_binary(fn)
            if use_stat:
                self.save_stat_features_to_file_binary(fn + "_ss")
        else:
            raise 'Unknown file mode %s!' % mode


    def load_from_file(self, fn, mode, use_stat,
            user_label='', id_label='', seq=0):
        '''
        General interface to load the signal object from files.
        '''

        if mode == 'csv':
            self.load_signal_from_file_csv(fn + '.csv')
            if use_stat:
                self.load_stat_features_from_file_csv(fn + '_ss.csv')
        elif mode == 'binary':
            # CAUTION: np.load() does not append ".npy" postfix to the fn.
            self.load_signal_from_file_binary(fn + ".npy")
            if use_stat:
                self.load_stat_features_from_file_binary(fn + '_ss.npy')
        elif mode == 'raw':
            self.load_from_file_raw(fn + '.txt')
        else:
            raise 'Unknown file mode %s!' % mode
        

        self.user_label = user_label
        self.id_label = id_label
        self.seq = seq






    def trim_pre_by_pos(self, threshold=5):
        '''
        Trim the start and the end where the hand does not move. The movement
        detection is based on position change (the default threshold is 5 mm)
        
        The trimming process is broken into two parts to accommodate filtering.
        This method is the first part, which just return the start and end 
        offsets without actually throwing away the data samples at the start 
        and the end.
        '''
        
        data = self.data
        l = self.l
        
        start_pos = np.zeros((3), np.float32)
        end_pos = np.zeros((3), np.float32)
        
        for v in range(3):
            start_pos[v] = (data[0][v] + data[1][v] + data[2][v]) / 3

        for v in range(3):
            end_pos[v] = (data[l - 1][v] + data[l - 2][v] + data[l - 3][v]) / 3
        
        start = 0
        for i in range(l):
            if np.linalg.norm(data[i][0:3] - start_pos) > threshold:
                
                start = i
                break
        
        end = 0
        for i in range(l - 1, 0, -1):
            if np.linalg.norm(data[i][0:3] - end_pos) > threshold:
                end = i
                break
        
        return (start, end)

    def trim_pre_by_acc(self, threshold):
        '''
        Trim the start and the end where the hand does not move. The movement
        detection is based on acceleration change (the default threshold is 
        5 mm/s^2)
        
        The trimming process is broken into two parts to accommodate filtering.
        This method is the first part, which just return the start and end 
        offsets without actually throwing away the data samples at the start 
        and the end.
        
        This method does not modify the data.
        '''
        
        # TODO: use an index variable in the parameter instead of hard coding.
        
        data = self.data
        l = self.l
        
        start_acc = np.zeros((3), np.float32)
        end_acc = np.zeros((3), np.float32)
        
        for v in range(3):
            start_acc[v] = (data[0, v + 6] + data[1, v + 6] + data[2, v + 6]) / 3

        for v in range(3):
            end_acc[v] = (data[l - 1, v + 6] + data[l - 2, v + 6] + data[l - 3, v + 6]) / 3
        
        start = 0
        for i in range(l):
            if np.linalg.norm(data[i][6:9] - start_acc) > threshold:
                
                start = i
                break
        
        end = 0
        for i in range(l - 1, 0, -1):
            if np.linalg.norm(data[i][6:9] - end_acc) > threshold:
                end = i
                break
        
        return (start, end)

    
    def trim_post(self, start, end):
        '''
        Trim the start and the end where the hand does not move.
        
        The trimming process is broken into two parts to accommodate filtering.
        This method is the second part, which throws away the data samples at
        according to the start and the end offset.
        
        This method actually modifies the data.
        '''
    
    
        l_new = end - start
        
        self.data = self.data[start:end, :]
        self.ts = self.ts[start:end]
        
        ts0 = self.ts[0]
        self.ts -= ts0
        
        self.l = l_new
        
        
    def filter(self, sample_freq, cut_freq):
        '''
        Low-pass filtering. It is assumed that a hand can not move very fast,
        so the high frequency components of the signal is noise.
        '''
        
        l = self.l
        data = self.data


        cut_l = int(cut_freq * l / sample_freq)
        
        dft_co = np.fft.fft(data, l, 0)
        
        for i in range(cut_l, l - cut_l):
    
            dft_co[i] = 0 + 0j
    
        ifft_c = np.fft.ifft(dft_co, l, 0)
    
        ifft = ifft_c.astype(np.float32)

        for i in range(l):
            self.data[i] = ifft[i]

        
        

    def resample_linear(self, re_freq):
        '''
        Resample the signal with a different frequency using linear 
        interpolation.
        '''
        data = self.data
        ts = self.ts
        l = self.l
        d = self.d
        
        duration = ts[l - 1] - ts[0]
        
        
        delta_t_new = 1000.0 / re_freq
        l_new = int(duration / 1000.0 * re_freq)
        
        ts_new = ts.copy()
        data_new = data.copy()
        
        ii = 0
        for i in range(l_new):
            
            ts_new[i] = i * delta_t_new
            
            while ts[ii] <= ts_new[i]:
                ii += 1
            
            ii = ii - 1
        
            dt = ts_new[i] - ts[ii]
            
            # linear interpolation
            # rate = (x_{ii + 1} - x{i}) / (ts[ii + 1] - ts[ii])
            # x_i^\prime = x_{ii} + rate * dt
            for v in range(d):
                rate = (data[ii + 1][v] - data[ii][v]) / (ts[ii + 1] - ts[ii])
                data_new[i][v] = data[ii][v] + rate * dt
        
        self.data = data_new[:l_new, :]
        self.ts = ts_new[:l_new, :]
        self.l = l_new

    def translate(self, xo, yo, zo):
        '''
        Translate the signal to a different reference frame without rotation.
        '''
        l = self.l
        data = self.data

        for i in range(l):
        
            # position translation (velocity and acc does not need translation)
            data[i][0] -= xo
            data[i][1] -= yo
            data[i][2] -= zo




    def rotate(self, theta, psi, phi):
        '''
        Rotate the reference frame by the specified yaw, pitch, and roll angle.
        '''
        
        # TODO: Check the correctness!!!
        
        l = self.l
        data = self.data

        
        Tm_pitch = np.matrix([  [cos(theta), 0, sin(theta)],
                                [0, 1, 0],
                                [-sin(theta), 0, cos(theta)]])
        
        
        Tm_yaw = np.matrix([    [cos(psi), -sin(psi), 0],
                                [sin(psi), cos(psi), 0],
                                [0, 0, 1]])
        
        
        Tm_roll = np.matrix([   [1, 0, 0],
                                [0, cos(phi), -sin(phi)],
                                [0, sin(phi), cos(phi)]])
        
        
        
        Tm = Tm_roll * Tm_yaw * Tm_pitch

        for i in range(l):
        
            pos = np.matrix([data[i][0], data[i][1], data[i][2]]).T
            velocity = np.matrix([data[i][3], data[i][4], data[i][5]]).T
            acc = np.matrix([data[i][6], data[i][7], data[i][8]]).T
        
            pos = Tm * pos
            velocity = Tm * velocity
            acc = Tm * acc
        
            for v in range(3):
                data[i][v] = pos[v]
                data[i][v + 3] = velocity[v]
                data[i][v + 6] = acc[v]
        
        
            # TODO: handle angular position
        
    def amplitude_normalize(self):
        '''
        Normalize the amplitude of the signal to zero mean and unit standard
        deviation.
        '''
        
        # TODO: rewrite this with matrix slice, or use nanmean(), nanstd()
        
        data = self.data
        
        
        mean = np.mean(data, axis = 0)
        std = np.std(data, axis = 0)
        
        #print(mean)
        #print(std)
        
#         mean = np.zeros((self.d), np.float32)
#         std = np.zeros((self.d), np.float32)
#           
#         for i in range(self.l):
#             for j in range(self.d):
#                   
#                 mean[j] += data[i][j]
#           
#         for j in range(self.d):
#             mean[j] /= self.l
#           
#         for i in range(self.l):
#             for j in range(self.d):
#   
#                 std[j] += (data[i][j] - mean[j]) ** 2
#           
#         for j in range(self.d):
#             
#             std[j] /= self.l
#             std[j] = math.sqrt(std[j])
          
        for i in range(self.l):
            for j in range(self.d):
                data[i, j] = (data[i, j] - mean[j]) / std[j]

        
#         mean = np.nanmean(data, axis = 0)
#         std = np.nanstd(data, axis = 0)
#         for i in range(self.l):
#             np.subtract(data[i], mean, data[i])
#             np.divide(data[i], std, data[i])
#  
#  
#         print(mean)
#         print(std)
#         
#         print(data)




    def pertube(self, t, axis, width, amplitude, sigma):
        '''
        pertube the signal at the specified time in the specified axis. 
        
        This method is currently used in data augmentation.
        '''
        
        pertubation = scipy.signal.gaussian(width, sigma) * amplitude
        
        start_data = t - width // 2
        start_pertubation = 0
        if start_data < 0:
            start_pertubation = -start_data
            start_data = 0
        
        end_data = start_data + width
        end_pertubation = width
        if end_data > self.l:
            end_pertubation -= (end_data - self.l)
            end_data = self.l
        
        #width_data = end_data - start_data
        #width_pertubation = end_pertubation - start_pertubation
        
        #print(self.l, t, width, start_data, end_data, 
        #    start_pertubation, end_pertubation, width_data, width_pertubation)
        
        
        self.data[start_data:end_data, axis] \
            += pertubation[start_pertubation:end_pertubation]

        
    def swap_segment(self, other, seg_start, seg_end, soft_margin):
        '''
        Swap a segment with another signal. This method is called by the data
        augmentation methods in FMSignalDataset.
        '''
        a = self.clone()
        b = other.clone()
        
        data_a = a.data
        ts_a = a.ts
        data_b = b.data
        ts_b = b.ts
        
        as1 = data_a[:seg_start, :]
        as2 = data_a[seg_start:seg_end, :]
        as3 = data_a[seg_end:, :]
        
        bs1 = data_b[:seg_start, :]
        bs2 = data_b[seg_start:seg_end, :]
        bs3 = data_b[seg_end:, :]
        
        ats1 = ts_a[:seg_start, :]
        ats2 = ts_a[seg_start:seg_end, :]
        ats3 = ts_a[seg_end:, :]
        
        bts1 = ts_b[:seg_start, :]
        bts2 = ts_b[seg_start:seg_end, :]
        bts3 = ts_b[seg_end:, :]
        
        data_a_new = np.concatenate([as1, bs2, as3], axis=0)
        ts_a_new = np.concatenate([ats1, bts2, ats3], axis=0)
        l_a = data_a_new.shape[0]
        
        data_b_new = np.concatenate([bs1, as2, bs3], axis=0)
        ts_b_new = np.concatenate([bts1, ats2, bts3], axis=0)
        l_b = data_b_new.shape[0]
        
        # smooth the segment edges
        if soft_margin != 0:
        
            margin1_start = max(0, seg_start - soft_margin)
            margin1_end = min(seg_start + soft_margin, min(l_a, l_b))
            margin1_factor = np.linspace(1, 0, margin1_end - margin1_start,
                endpoint=True, dtype=np.float32)
            
            # print(margin1_start, margin1_end)
            
            for i, ii in \
                zip(range(margin1_start, margin1_end), 
                    range(margin1_end - margin1_start)):
                
                data_a_new[i] = margin1_factor[ii] * data_a[i] \
                                + (1 - margin1_factor[ii]) * data_b[i]
                data_b_new[i] = margin1_factor[ii] * data_b[i] \
                                + (1 - margin1_factor[ii]) * data_a[i]
            
    
            margin2_start = max(0, seg_end - soft_margin)
            margin2_end = min(seg_end + soft_margin, min(l_a, l_b))
            margin2_factor = np.linspace(1, 0, margin2_end - margin2_start,
                endpoint=True, dtype=np.float32)
            
            # print(margin2_start, margin2_end)
            
            for i, ii in \
                zip(range(margin2_start, margin2_end), 
                    range(margin2_end - margin2_start)):
                
                data_a_new[i] = margin2_factor[ii] * data_b[i] \
                                + (1 - margin2_factor[ii]) * data_a[i]
                data_b_new[i] = margin2_factor[ii] * data_a[i] \
                                + (1 - margin2_factor[ii]) * data_b[i]
        
        a.data = data_a_new
        a.ts = ts_a_new
        a.l = l_a
        b.data = data_b_new
        b.ts = ts_b_new
        b.l = l_b
        
        return a, b


    def stretch(self, l_new, sample_period=20):
        '''
        Stretch the signal to the specified new length, i.e., stretch in time,
        by linear interpolation.
        
        This method is currently used in temporal normalization for 
        identification models.
        '''
        # CAUTION: delta_new may not be an integer any more!!!
        
        l = self.l
        d = self.d
        delta_new = l / l_new 
        
        data_new = np.zeros((l_new, d), np.float32)
        ts_new = np.zeros((l_new, 1), np.float32)
        
        data = self.data
        
        # print(l, l_new, delta_new)
        
        for i in range(l_new):
            
            ts_new[i] = sample_period * i
            
            it = i * delta_new
            ii = int(math.floor(it))
            dt = it - ii
            
            # print(i, delta_new, it, ii)
            
            for v in range(d):
                rate = data[ii + 1][v] - data[ii][v] \
                    if ii + 1 < l else data[ii][v] - data[ii - 1][v]
                data_new[i][v] = data[ii][v] + rate * dt
        
        
        self.l = l_new
        self.d = d
        self.ts = ts_new
        self.data = data_new


    def stretch_segment(self, seg_start, seg_end, seg_l_new, sample_period=20):
        '''
        Stretch a segment of the signal.
        
        This method is currently used in data augmentation.
        '''
        
        
        l = self.l
        d = self.d
        seg_l = seg_end - seg_start
        l_new = self.l - seg_l + seg_l_new
        delta_new = seg_l / seg_l_new
        
        seg_start_new = seg_start
        seg_end_new = seg_start_new + seg_l_new
        
        data_new = np.zeros((l_new, d), np.float32)
        ts_new = np.zeros((l_new, 1), np.float32)

        data = self.data
        
        data_new[0:seg_start] = data[0:seg_start]
        data_new[seg_end_new:l_new] = data[seg_end:l]
        
        for i in range(seg_l_new):
            
            it = seg_start + i * delta_new
            ii_old = int(math.floor(it))
            ii_new = seg_start + i
            dt = it - ii_old
            
            # print(i, delta_new, it, ii)
            
            for v in range(d):
                rate = data[ii_old][v] - data[ii_old][v] \
                    if ii_old + 1 < l else data[ii_old][v] - data[ii_old - 1][v]
                data_new[ii_new][v] = data[ii_old][v] + rate * dt
        
        
        for i in range(l_new):
            
            ts_new[i] = sample_period * i

        self.l = l_new
        self.d = d
        self.ts = ts_new
        self.data = data_new




    def stat_feature_extract_pre(self, segs=3):
        '''
        Extract the statistical features (first part).
        
        Currently the statistical features contain the following:
        
        * Mean of of each sensor axis.
        * Variance of each sensor axis.
        * Correlation between pairs of adjacent sensor axex of the same type.
        * Magnitude (i.e., sum of amplitude) of each sensor axis.
        * Signal entropy of each sensor axis.
        
        Statistical features can be extracted both from the whole signal or
        from just a segment. The segs argument specifies how many equal-sized
        segments should be used for feature extraction.
        
        Note that statistical feature extraction is also separated into two
        parts. This method is the first part, which extract the first four
        types of statistical features (i.e., except entropy).
        
        Note that this method should be called before amplitude normalization.
        
        '''
        # CAUTION: Do statistical feature extraction before amplitude 
        # normalization
        
        l = self.l
        d = self.d
        sl = l // segs
        
        # we have 5 types of statistical features in total
        dimension_ss = 5
        stat = np.zeros((segs, dimension_ss, d), np.float32)
        
        for i in range(segs):
            start = i * sl
            end = (i + 1) * sl
            data_seg = self.data[start:end, :]
            
            # mean
            mean_seg = np.mean(data_seg, axis=0)
            stat[i, 0] = mean_seg
            
            # std
            std_seg = np.std(data_seg, axis=0)
            stat[i, 1] = std_seg
        
            # axis correlation, 3 axes a group
            # CAUTION: we assume that d is always a multiple of 3
            for j in range(d // 3):
                
                axis0 = j * (d // 3) + 0
                axis1 = j * (d // 3) + 1
                axis2 = j * (d // 3) + 2
                
                co01 = np.corrcoef(data_seg[:, axis0], data_seg[:, axis1])[0,1]
                co12 = np.corrcoef(data_seg[:, axis1], data_seg[:, axis2])[0,1]
                co20 = np.corrcoef(data_seg[:, axis2], data_seg[:, axis0])[0,1]
        
                stat[i, 2, axis0] = co01
                stat[i, 2, axis1] = co12
                stat[i, 2, axis2] = co20
        
            # magnitude
            data_seg_abs = np.absolute(data_seg)
            mag_seg = np.sum(data_seg_abs, axis=0)
            stat[i, 3] = mag_seg
        
        
        self.stat = stat
        
                
    def stat_feature_extract_post(self, segs=3):
        '''
        Extract the statistical features (second part).

        This method is the second part of the statistical feature extraction,
        which extracts signal entropy of each sensor axis.
        
        Note that this method should be called after amplitude normalization.
        '''
        
        l = self.l
        d = self.d
        sl = l // segs
    
        stat = self.stat

        for i in range(segs):
            start = i * sl
            end = (i + 1) * sl
            data_seg = self.data[start:end, :]

            # entropy
            for j in range(d):
                
                column = data_seg[:, j]
                # print(column.shape)
                # NOTE: we use 20 bins and (-3 * sigma, + 3 * sigma) as range.
                # CAUTION: assume amplitude normalization is done first.
                hist_j, _ = np.histogram(column, bins=20, 
                    range=(-3, 3), density=True)
                # print(hist_j)
                entropy_j = scipy.stats.entropy(hist_j)
                
                stat[i, 4, j] = entropy_j

    def align_signal_to(self, template, window, penalty):
        '''
        Align the signal self to the template signal, using the DTW algorithm.
        '''
        
        
        l_new = template.l

        tup = dtw(template.data, self.data, template.l, self.l, 
                window = window, penalty = penalty)
#        tup = dtw_c(template.data, self.data, template.l, self.l,
#                  window=window, penalty=penalty)
    
        #(dist, dists, dir, a1start, a1end, a2start, a2end, data_new) = tup

        # print(dist)


        ts_new = template.ts.copy()
        
        return (ts_new, tup[-1], l_new)


    def distance_to(self, other):
    
        '''
        Calculate the D_{ij} = |T_{ij} - S_{ij}|, i.e., element-wise distance 
        between the template / signal (self) and the other signal (other).
        
        CAUTION: other must have been aligned to self
        '''
    
        return np.absolute(self.data - other.data)


    def clone(self):
        '''
        Deep copy of the object.
        '''
        ts_clone = self.ts.copy()
        data_clone = self.data.copy()
        
        return FMSignal(self.l, self.d, ts_clone, data_clone, self.stat.copy(),
                        self.user_label, self.id_label, self.seq)





    def __str__(self, *args, **kwargs):
        '''
        Convert the object to a human readable string (mainly for debugging).
        '''
        
        return '%s_%s_%02d' % (self.user_label, self.id_label, self.seq)

class FMSignalLeap(FMSignal):
    '''
    FMSignal signal collected by the Leap Motion controller.
    
    This class is derived from the abstract base class FMSignal by adding a few
    addtional information including:
    
    data_aux:   position trajectory of each joint (not just the finger tip).
                This field is only available if the data is from a raw file.
                It is currently a l * 5 * 5 * 3 tensor, i.e., 5 fingers,
                5 joints on each finger, and 3 coordinates for each joint.
    confs:      confidence value of each sample (l dimension vector).
    valids:     whether the sample is valid (l dimension vector).
    
    handgeo:        hand geometry, a 22 components vector.
    handgeo_std:    the standard deviation of each component of handgeo, also a
                    22 component vector.
    
    The data contains samples of 9 sensor axes including 3D position, 
    3D velocity, and 3D acceleration.


    Note that currently we use the center of the hand instead of the finger tip
    due to various data quality issues.
    
    See "The FMKit Dataset Format" document for more information.
    '''


    def __init__(self, length=-1, dimension=-1, ts=None, data=None,
            stat=None, user_label='', id_label='', seq=0,
            data_aux=None, confs=None, valids=None):
        '''
        Default constructor, which essentially constructs nothing.
        '''
        
        FMSignal.__init__(self, length, dimension, ts, data, stat,
            user_label, id_label, seq)
        
        
        self.data_aux = data_aux
        self.confs = confs
        self.valids = valids

        self.handgeo = None
        self.handgeo_std = None
        
    
    def load_from_file_raw(self, fn, n=2048, m=9):
        '''
        Load raw data (i.e., directly captured from the data collection client)
        from a file.
        
        args:
        
        fn   file name
        n    capacity of the first dimension of the data 
             (l must be less than N)
        m    capacity of the second dimension of the data 
             (d must be less than M)
        
        CAUTION: n and m must be big enough to hold the samples in the file.
        
        Note that: 
           timestamp is always in ms
           frequency is always in Hz
           position is always in mm
           velocity is always in mm/ms (equivalent to m/s)
           acceleration is always in mm/ms^2 (equivalent to 1000 m/s^2)
        
        TODO: angular position, etc.
        
        Note that:
           float32 may not be big enough to hold raw timestamp (uint32).
           float64 is used to represent raw timestamp, and after processing, 
           timestamps are casted to float32.

        Note that this method just load the data. It does not extract hand
        geometry features.
        
        See "The FMKit Dataset Format" document for the raw data format.
        '''
        

        data = np.zeros((n, m), np.float32)
        data_aux = np.zeros((n, 5, 5, 3), np.float32)
        ts = np.zeros((n, 1), np.float64)
        confs = np.zeros((n, 1), np.float32)
        valids = np.zeros((n, 1), np.int32)
        
        l = 0
        d = m  
        i = 0
        
        offset_hand = 1 + 6
        offset_bone = 1 + 6 + 9
        
        # TODO: rewrite this with np.loadtxt()
        
        
        # load data from file
        with open(fn, 'r') as fd:
        
            reader = csv.reader(fd)
            for row in reader:
        
                strs = []
                for column in row:
                    strs.append(column.lstrip().rstrip())
        
        
                ts[i] = row[0]
                
                # fix timestamp wraping over maximum of uint32
                if i > 0 and ts[i] < ts[i - 1]:
                    ts[i] += 4294967295.0
                
#               for j in range(6):
#                   tip_co[i][j] = strs[1 + j]
                
                # load hand positions
                # CAUTION: axis mapping: yzx -> xyz
                data[i][0] = strs[offset_hand + 2]
                data[i][1] = strs[offset_hand + 0]
                data[i][2] = strs[offset_hand + 1]
                
                # load hand orientation
                # TODO: process this to three Euler angles
#                 for j in range(3):
#                     data[i][j + 9] = strs[offset_hand + j + 3]
#                     data[i][j + 12] = strs[offset_hand + j + 6]
                    
                # load joint positions
                for j in range(5):
                    for k in range(5):
                            index = j * 5 * 3 + k * 3
                            data_aux[i][j][k][0] = strs[offset_bone + index + 2]
                            data_aux[i][j][k][1] = strs[offset_bone + index + 0]
                            data_aux[i][j][k][2] = strs[offset_bone + index + 1]
                            
#                 for j in range(5):
#                     for k in range(4):
#                         index = j * 4 * 2 + k * 2
#                         bone_geo[i][j][k][0] = strs[1 + 6 + 9 + 5 * 5 * 3 + index + 0]
#                         bone_geo[i][j][k][1] = strs[1 + 6 + 9 + 5 * 5 * 3 + index + 1]
        
                confs[i] = strs[-2]
                valids[i] = strs[-1]
                i += 1
                l += 1

        
        # fix timestamp offset
        # timestamp is in millisecond
        ts0 = ts[0]
        ts -= ts0
        ts /= 1000
        
        ts = ts.astype(np.float32)
        
     
        self.l = l
        self.d = d
        self.ts = ts[:l]
        self.data = data[:l, :]

        self.data_aux = data_aux[:l, :]
        self.confs = confs[:l]
        self.valids = valids[:l]

        
    def save_to_file(self, fn, mode, use_stat, use_handgeo):
        '''
        General interface to dump the signal object to files.
        '''
        
        FMSignal.save_to_file(self, fn, mode, use_stat)
        
        if use_handgeo:
            self.save_handgeo(fn, mode)

    def load_from_file(self, fn, mode, use_stat, use_handgeo,
        user_label='', id_label='', seq=0):
        '''
        General interface to load the signal object from files.
        '''

        FMSignal.load_from_file(self, fn, mode, use_stat, user_label, id_label, seq)
    
        if use_handgeo:
        
            if mode == 'raw':
                
                self.handgeo_extract()
                
            else:
                
                self.load_handgeo(fn, mode)

    
    @classmethod
    def construct_from_file(cls, fn, mode, use_stat, use_handgeo,
            user_label='', id_label='', seq=0):
        '''
        Factory method to build the signal by loading a file.
        '''
        
        signal = FMSignalLeap()
        signal.load_from_file(fn, mode, use_stat, use_handgeo, user_label, id_label, seq)

        return signal
    
    def fix_missing_points(self):
        '''
        Fix missing data samples by linear interpolation. The missing samples
        are mainly caused by the motion of the hand which are outside the field
        of the view of the sensor.
        '''
        
        i = 1
        
        while i < self.l - 1:
        
            # find the start of a missing segment
            while i < self.l - 1:
            
                if self.valids[i] == 0:
                        break
                else:
                        i += 1
                        
            # find the end of a missing segment
            j = i
            while j < self.l - 1:
            
                if self.valids[j] == 1:
                        break
                else:
                        j += 1
    
            # If missing points found between i and j, fix them.
            # If no missing point found, just skip.
            if i < j:
            
                # fix data[i:j]
                start = self.data[i - 1]
                start_ts = self.ts[i - 1]
                end = self.data[j]
                end_ts = self.ts[j]

                for k in range(i, j):

                        k_ts = self.ts[k]
                        rate = (k_ts - start_ts) * 1.0 / (end_ts - start_ts)
                        self.data[k] = start + (end - start) * rate
                        self.valids[k] = 1

                # then find another missing sement in the next iteration
                i = j
        
    def estimate_velocity_acc(self):
        '''
        Estimate velocity and acceleration from the position data samples.
        '''
        
        l = self.l
        data = self.data
        ts = self.ts
        
        for i in range(1, l - 1):
            for v in range(3):
                
                v1 = (data[i + 1][v] - data[i][v]) / (ts[i + 1] - ts[i])
                v2 = (data[i][v] - data[i - 1][v]) / (ts[i] - ts[i - 1])
                data[i][v + 3] = (v1 + v2) / 2
        
                if (ts[i + 1] - ts[i]) == 0 or (ts[i] - ts[i - 1]) == 0:
                
                    str_ts = 'Abnormal ts: %16s %16s %2d %d, %f\t' % (self.user_label,
                            self.id_label, self.seq, i, ts[i])
                    print(str_ts)
                    break
        
        for v in range(3, 6):
            data[0][v] = data[1][v]
            data[l - 1][v] = data[l - 2][v]
        
        # data = fmkit.utils.low_pass_filter(data, l, 10, freq)

        
        for i in range(1, l - 1):
            for v in range(3, 6):
                
                a1 = (data[i + 1][v] - data[i][v]) / (ts[i + 1] - ts[i])
                a2 = (data[i][v] - data[i - 1][v]) / (ts[i] - ts[i - 1])
                data[i][v + 3] = (a1 + a2) / 2
  
        for v in range(6, 9):
            data[0][v] = data[1][v]
            data[l - 1][v] = data[l - 2][v]
      
        
        # data = fmkit.utils.low_pass_filter(data, l, 10, freq)

        self.data = data


    
    def posture_normalize(self):
        '''
        Normalize the posture by translation and rotation.
        
        Note that the new x axis is the average of the pointing direction,
        the new y axis is the horizontal direction, and the new z axis is
        determined by the new x and y axes.
        '''

        l = self.l
        data_aux = self.data_aux


        # calculate origin and prefered x axis (the v vector)
        xo = 0
        yo = 0
        zo = 0
        
        xv = 0
        yv = 0
        zv = 0

        for i in range(l):

            for j in range(5):
    
                xo += data_aux[i][j][0][0]
                yo += data_aux[i][j][0][1]
                zo += data_aux[i][j][0][2]
    
            # use the average direction of the last segment of middle finger
            xv += (data_aux[i][2][1][0] - data_aux[i][2][0][0])
            yv += (data_aux[i][2][1][1] - data_aux[i][2][0][1])
            zv += (data_aux[i][2][1][2] - data_aux[i][2][0][2])


        xo /= (l * 5)
        yo /= (l * 5)
        zo /= (l * 5)
        
        xv /= l
        yv /= l
        zv /= l

        norm_square = (xv * xv + yv * yv + zv * zv)
        norm = math.sqrt(norm_square)
        
        xv /= norm
        yv /= norm
        zv /= norm

        # print('centeriod: (%f, %f, %f, %f, %f, %f)' % (xo, yo, zo, xv, yv, zv))
        
        # CAUTION: theta is restricted to be between -pi / 2 and pi / 2
        theta = atan(zv / xv)
        
        # psi is from - pi to pi
        psi = atan2(-cos(theta) * yv + sin(theta) * zv, xv)
        
        # TODO: fix roll using hand norm and hand direction
        phi = 0
        
        # print('rotation: theta = %f, psi = %f, phi = %f' %(theta, psi, phi))

        self.translate(xo, yo, zo)
        self.rotate(theta, psi, phi)

    def preprocess_shape(self, trim_th=5, filter_cut_freq=10, resample_freq=50):
        '''
        Preprocess the shape of the signal without amplitude normalization.
        '''
        
        self.fix_missing_points()
        
        tup = self.trim_pre_by_pos(trim_th)
        
        self.estimate_velocity_acc()
                
        sample_freq = self.l / (self.ts[self.l - 1]) * 1000.0

        self.filter(sample_freq, filter_cut_freq)
        
        self.trim_post(*tup)
        
        self.resample_linear(resample_freq)
        
        self.posture_normalize()


    def preprocess(self, trim_th=5, filter_cut_freq=10, resample_freq=50):
        '''
        Preprocess the signal (including amplitude normalization)
        '''
        
        self.preprocess_shape(trim_th, filter_cut_freq, resample_freq)
        
        self.stat_feature_extract_pre()
        
        self.amplitude_normalize()
        
        self.stat_feature_extract_post()

        # assert(self.l != self.data.shape[0])

    def handgeo_extract(self):
        
        '''
        Extract hand geometry features from data_aux instead of using the
        sensor's output of hand geometry.
        '''
        
        l = self.l
        data_aux = self.data_aux

        handgeo_samples = np.zeros((100, 22), np.float32)
        ii = 0
        
        for i in range(l - 100, l):
            
            handgeo_sample = np.zeros(22, np.float32)
            
            # bones of index finger, mid finger, ring finger, and little finger
            for j in range(0, 4):
                
                for k in range(4):
                    
                    handgeo_sample[j * 4 + k] = np.linalg.norm(
                        data_aux[i, j + 1, k + 1] - data_aux[i, j + 1, k])

            # bones on the thumb
            handgeo_sample[16] = np.linalg.norm(data_aux[i, 0, 2] - data_aux[i, 0, 1])
            handgeo_sample[17] = np.linalg.norm(data_aux[i, 0, 3] - data_aux[i, 0, 2])
            handgeo_sample[18] = np.linalg.norm(data_aux[i, 0, 4] - data_aux[i, 0, 3])

            # hand widths
            handgeo_sample[19] = np.linalg.norm(data_aux[i, 1, 1] - data_aux[i, 2, 1])
            handgeo_sample[20] = np.linalg.norm(data_aux[i, 2, 1] - data_aux[i, 3, 1])
            handgeo_sample[21] = np.linalg.norm(data_aux[i, 3, 1] - data_aux[i, 4, 1])
            
            handgeo_samples[ii] = handgeo_sample
            ii += 1

        handgeo = np.mean(handgeo_samples, 0)
        handgeo_std = np.std(handgeo_samples, 0)

        # print(handgeo_samples)
        # print(handgeo)
        # print(handgeo_std)

        self.handgeo = handgeo
        self.handgeo_std = handgeo_std

    def save_handgeo(self, fn, mode):
        '''
        Dump the hand geometry features to file.
        '''
        fn += '_handgeo'

        if mode == 'binary':
            
            array = np.concatenate((self.handgeo, self.handgeo_std))
            np.save(fn, array)
        
        elif mode == 'csv':
            
            array = np.concatenate((self.handgeo, self.handgeo_std))
            np.savetxt(fn, array, fmt='%.6f', delimiter=', ')
        
        else:
            
            raise 'Unknown file mode %s!' % mode
    
    def load_handgeo(self, fn, mode):
        '''
        Load the hand geometry features from file.
        '''

        fn += '_handgeo'
        
        if mode == 'binary':
            
            fn += '.npy'
            
            array = np.load(fn)
    
            m = int(array.shape[0] / 2)
            
            self.handgeo = array[:m]
            self.handgeo_std = array[m:]

        elif mode == 'csv':
            
            array = np.loadtxt(fn, dtype=np.float32, delimiter=',')
            self.handgeo = array[:22]
            self.handgeo_std = array[22:]

        else:
            
            raise 'Unknown file mode %s!' % mode
            

    def align_to(self, template, window=50, penalty=0):
        '''
        Align the signal to a template (or just another signal)
        '''
        ts_new, data_new, l_new = FMSignal.align_signal_to(self,
            template, window, penalty)
        
        d = self.d

        fms_aligned = FMSignalLeap(l_new, d, ts_new, data_new, self.stat.copy(),
            user_label=self.user_label, id_label=self.id_label, seq=self.seq)
        
        fms_aligned.handgeo = self.handgeo.copy()
        fms_aligned.handgeo_std = self.handgeo_std.copy()
        
        fms_aligned.l_origin = self.l

        return fms_aligned

    def clone(self):
        '''
        Deep copy of the signal.
        '''
        ts_clone = self.ts.copy()
        data_clone = self.data.copy()
        
        fms_clone = FMSignalLeap(self.l, self.d, ts_clone, data_clone, self.stat.copy(),
            user_label=self.user_label, id_label=self.id_label, seq=self.seq)

        fms_clone.handgeo = self.handgeo.copy()
        fms_clone.handgeo_std = self.handgeo_std.copy()
        
        return fms_clone





class FMSignalGlove(FMSignal):
    '''
    FMSignal signal collected by the data glove.
    
    This class is derived from the abstract base class FMSignal. It does not 
    introduce new fields.
    
    The data contains samples of 9 sensor axes including 3D acceleration, 
    3D angular velocity, and three Euler angles.

    
    See "The FMKit Dataset Format" document for more information.
    '''


    def __init__(self, length=-1, dimension=-1, ts=None, data=None, stat=None,
            user_label='', id_label='', seq=0):
        '''
        Default constructor, which essentially constructs nothing.
        '''
        
        FMSignal.__init__(self, length, dimension, ts, data, stat, 
            user_label=user_label, id_label=id_label, seq=seq)
        
    def load_from_file_raw(self, fn):
        '''
        Load raw data (i.e., directly captured from the data collection client)
        from a file.

        CAUTION: 
           timestamp is always in ms
           frequency is always in Hz
           position is always in mm
           velocity is always in mm/ms (equivalent to m/s)
           acceleration is always in mm/ms^2 (equivalent to 1000 m/s^2)

        TODO: angular position, etc.
        
        '''
        
        array = np.loadtxt(fn, dtype=np.float32, delimiter=',')
        
        # CAUTION: the raw timestamps in glove data are in millisecond.
        ts = array[:, 0:1]
        
        
        acc0 = array[:, 1:4]
        gyro0 = array[:, 4:7]
        gravity0 = array[:, 7:10]
        euler0 = array[:, 10:13]

        # CAUTION: Currently we only uses the first inertial sensor.
        
#         acc1 = array[:, 13:16]
#         gyro1 = array[:, 16:19]
#         gravity1 = array[:, 19:22]
#         euler1 = array[:, 22:25]

        # CAUTION: Euler angles wrap at plus / minus 180 degree.
        # Here we make it continuous.
        # we do not offset it (i.e., change the origin) because eventually 
        # they are normalized.

        lt = array.shape[0]
        
        euler0_t = euler0[lt - 50:lt, :]
        euler0_mean = np.mean(euler0_t, axis=0)
        euler0 = euler0 - euler0_mean

        for i in range(euler0.shape[0]):
            for j in range(euler0.shape[1]):
                
                if euler0[i, j] > 180:
                    euler0[i, j] -= 360
                elif euler0[i, j] < -180:
                    euler0[i, j]

#         for i in range(euler1.shape[0]):
#             for j in range(euler1.shape[1]):
#                 
#                 if euler1[i, j] > 180:
#                     euler1[i, j] -= 360
#                 elif euler1[i, j] < -180:
#                     euler1[i, j]

        # CAUTION: euler angles are in degrees, change it to radian
        
        # euler0 = euler0 * math.pi / 180
        # euler1 = euler1 * math.pi / 180

        data = np.concatenate((euler0, gyro0, acc0), axis=1)
        
        l = data.shape[0]
        d = data.shape[1]

        for i in range(l - 1):
            
            if ts[i + 1] < ts[i]:
                ts[i + 1] = ts[i] + 20

        self.l = l
        self.d = d
        self.ts = ts
        self.data = data

    @classmethod
    def construct_from_file(cls, fn, mode, use_stat,
            user_label='', id_label='', seq=0):
        '''
        Factory method to build the signal by loading a file.
        '''
    
        signal = FMSignalGlove()
        signal.load_from_file(fn, mode, use_stat, user_label, id_label, seq)

        return signal
    
    def reference_frame_translate(self):
        
        # TODO: translate from sensor frame to world frame
        
        pass
    
    def estimate_position_velocity(self):
        
        # TODO: estimate position and velocity from linear acceleration
        
        pass

    def posture_normalize(self):
        
        # TODO: 
        
        pass
    
    def preprocess(self, trim_th=5, filter_cut_freq=10, resample_freq=50):
        '''
        Preprocess the signal (including amplitude normalization)
        '''        
        
        self.reference_frame_translate()
        
        tup = self.trim_pre_by_acc(trim_th)
        
        self.estimate_position_velocity()

        sample_freq = self.l / (self.ts[self.l - 1]) * 1000.0

        self.filter(sample_freq, filter_cut_freq)
        
        self.trim_post(*tup)
        
        # CAUTION: The glove device samples at 50 Hz, so no need to resample.
        
        # self.resample_linear(resample_freq)
        
        self.posture_normalize()
        
        self.stat_feature_extract_pre()
        
        self.amplitude_normalize()
        
        self.stat_feature_extract_post()


    def align_to(self, template, window=50, penalty=0):
        '''
        Align the signal to a template (or just another signal)
        '''

        ts_new, data_new, l_new = FMSignal.align_signal_to(self,
            template, window, penalty)
        
        d = self.d
        
        signal_aligned = FMSignalGlove(l_new, d, ts_new, data_new, self.stat.copy(),
            user_label=self.user_label, id_label=self.id_label, seq=self.seq)
        
        signal_aligned.l_origin = self.l

        return signal_aligned

    def clone(self):
        '''
        Deep copy of the signal.
        '''
        ts_clone = self.ts.copy()
        data_clone = self.data.copy()
        stat_clone = self.stat.copy()
        
        fms_clone = FMSignalGlove(self.l, self.d, ts_clone, data_clone,
            stat_clone, user_label=self.user_label, id_label=self.id_label, seq=self.seq)

        return fms_clone
        

class FMSignalTemplate(FMSignal):
    '''
    FMSignal signal template constructed from a collection of signals.
    
    In most cases, template is identical to a signal. However, there are a few
    additional fields including:
    
    variance:   the variance of the samples constructing the template.
                The variance is calculates at sample level, so it has the same
                dimension as the data.
    
    Note that this class is the abstract class. Do not instantiate it directly.
    Instead, use the derived class listed below such as FMSignalTemplateLeap or
    FMSignalTemplateGlove
    
    '''


    def __init__(self, length=-1, dimension=-1, ts=None, data=None,
            stat=None, user_label='', id_label='', seq=0,
            variance=None, signals_aligned=None):
        '''
        Default constructor, which essentially constructs nothing.
        '''
        
        FMSignal.__init__(self, length, dimension, ts, data, stat,
            user_label=user_label, id_label=id_label, seq=seq)

        self.variance = variance
        self.stat = stat
        self.signals_aligned = signals_aligned


    @classmethod
    def prepare_construction_from_signals(cls, signals, template_index, use_stat,
            window=50, penalty=0):
        '''
        Construct the template by aligning and average a set of signals.
                        
        signals:        the set of signals
        template_index: the index of signal which others align to.
        use_stat:       True if statistical features of the template are also constructed.
        window:         alignment window, see utils.dtw().
        penalty:        element level misalign penalty, see utils.dtw().
        
        Note that this method is only called by the derived class. Do not use
        this method directly.
        
        '''
        
        template = signals[template_index]
        signals_aligned = [template]
        
        k = len(signals)
        
        # construct signal template
        
        data = template.data.copy()
        ts = template.ts.copy()
        
        variance = np.zeros(template.data.shape, template.data.dtype)
        
        for signal in signals:
            
            if signal == template:
                
                continue
            
            signal_aligned = signal.align_to(template, window, penalty)
            signals_aligned.append(signal_aligned)
        
            data += signal_aligned.data
        
        data /= k
        
        for signal_aligned in signals_aligned:
            
            variance += np.square(signal_aligned.data - data)

        variance /= k

        # construct statistical features of the template
        stat = None
        
        if use_stat:
            
            assert (template.stat is not None), 'Error in constructing ' \
                + 'statistical features of the template: ' \
                + 'stat of the signal is missing.'
            
            
            stat = template.stat.copy()
    
            for signal in signals:
                
                if signal == template:
                    
                    continue

                assert (signal.stat is not None), 'Error in constructing ' \
                    + 'statistical features of the template: ' \
                    + 'stat of the signal is missing.'
                
                stat += signal.stat
                
            stat /= k

        return (ts, data, variance, stat, signals_aligned)


    def dump_template_signal_to_file_csv(self, fn):
        '''
        Dump the template to file.
        '''
        
        array = np.concatenate((self.ts, self.data, self.variance), axis=1)
        np.savetxt(fn, array, fmt='%.6f', delimiter=', ')

    def load_template_signal_from_file_csv(self, fn):
        '''
        Load the template from file.
        
        Note that only the statistical features are not loaded.
        '''
        
        array = np.loadtxt(fn, dtype=np.float32, delimiter=',')

        ts = array[:, 0:1]
        data_and_varance = array[:, 1:]
        
        l = data_and_varance.shape[0]
        d = int(data_and_varance.shape[1] / 2)
        
        data = data_and_varance[:, :d]
        variance = data_and_varance[:, d:]

        self.l = l
        self.d = d
        self.ts = ts[:l]
        self.data = data[:l, :]

        self.variance = variance
        self.stat_features = None
        self.signals_aligned = None
        
    def save_template_stat_to_file_csv(self, fn):
        '''
        Dump the statistical features to a CSV file.
        '''

        shape = self.stat.shape
        array = self.stat.reshape((shape[0] * shape[1], shape[2]))
        np.savetxt(fn, array, fmt='%.6f', delimiter=', ')

    def load_template_stat_from_file_csv(self, fn):
        '''
        Load the statistical features from a CSV file.
        '''

        array = np.loadtxt(fn, dtype=np.float32, delimiter=',')
        shape = array.shape
        self.stat = array.reshape((shape[0] // 5, 5, self.d))
                
    def save_template_signal_to_file_binary(self, fn):
        '''
        Dump the template to a .npy file.
        '''
        
        array = np.concatenate((self.ts, self.data, self.variance), axis=1)
        np.save(fn, array)
        
    def load_template_signal_from_file_binary(self, fn):
        '''
        Load the template from a CSV file.
        '''
        
        array = np.load(fn)
        
        l = array.shape[0]
        d = (array.shape[1] - 1) // 2
        
        ts = array[:, 0:1]
        data = array[:, 1:(d + 1)]
        variance = array[:, (d + 1):]
        
        stat_features = []

        self.l = l
        self.d = d
        self.ts = ts[:l]
        self.data = data[:l, :]

        self.variance = variance
        self.stat_features = stat_features
        self.signals_aligned = None

    def save_template_stat_to_file_binary(self, fn):
        '''
        Dump the statistical features to a .npy file.
        '''

        np.save(fn, self.stat)

    def load_template_stat_from_file_binary(self, fn):
        '''
        Load the statistical features from a .npy file.
        '''

        self.stat = np.load(fn)
                

    def save_to_file(self, fn, mode, use_stat):
        '''
        General interface to dump the signal object to files.
        '''
        
        if mode == 'csv':
            self.dump_template_signal_to_file_csv(fn + '.csv')
            if use_stat:
                self.save_template_stat_to_file_csv(fn + '_ss.csv')
        elif mode == 'binary':
            self.save_template_signal_to_file_binary(fn)
            if use_stat:
                self.save_template_stat_to_file_binary(fn + '_ss')
        else:
            raise 'Unknown file mode %s!' % mode
        
    
    
    def load_from_file(self, fn, mode, use_stat,
        user_label='', id_label='', seq=0):
        '''
        General interface to load the signal object from files.
        '''

        if mode == 'csv':
            self.load_template_signal_from_file_csv(fn + '.csv')
            if use_stat:
                self.load_template_stat_from_file_csv(fn + '_ss.csv')
        elif mode == 'binary':
            self.load_template_signal_from_file_binary(fn + ".npy")
            if use_stat:
                self.load_template_stat_from_file_binary(fn + "_ss.npy")
        else:
            raise 'Unknown file mode %s!' % mode

        self.user_label = user_label
        self.id_label = id_label
        self.seq = seq

    def update(self, new_signal, factor, use_stat):
        '''
        Update the template with a new signal.
        
        new_signal: the new signal S used to update the template.
        factor: update factor, i.e., T_{new} = (1 - factor) * T + S * factor
        
        CAUTION: The new signal must be aligned to the template
        '''
        
        # update the signal template
        self.data = self.data * (1 - factor) + new_signal.data * factor
        
        # update the statistical features
        if use_stat:
            self.stat = self.stat * (1 - factor) + new_signal.stat * factor

        
class FMSignalTemplateLeap(FMSignalTemplate, FMSignalLeap):
    '''
    FMSignal signal template (leap motion controller version).
    
    This class is derived from both FMSignalTemplate and FMSignalLeap.
        
    '''

    def __init__(self, length=-1, dimension=-1, ts=None, data=None,
            stat=None, user_label='', id_label='', seq=0,
            variance=None, signals_aligned=None):
        '''
        Default constructor.
        '''

        FMSignalTemplate.__init__(self, length, dimension, ts, data,
            stat=stat, user_label=user_label, id_label=id_label, seq=seq,
            variance=variance, signals_aligned=signals_aligned)
        
        FMSignalLeap.__init__(self, length, dimension, ts, data,
            stat=stat, user_label=user_label, id_label=id_label, seq=seq)

        self.handgeo = None
        self.handgeo_std = None


    @classmethod
    def construct_from_signals(cls, signals, template_index, use_stat, use_handgeo,
            window=50, penalty=0):
        '''
        Factory method to construct the template by aligning and average a set
        of signals.
        '''
        
        signal_t = signals[template_index]
        l = signal_t.l
        d = signal_t.d
        k = len(signals)
        
        tup = FMSignalTemplate.prepare_construction_from_signals(signals,
            template_index, use_stat, window, penalty)
        (ts, data, variance, stat, signals_aligned) = tup
        
        template = cls(l, d, ts, data, stat,
           signal_t.user_label, signal_t.id_label, signal_t.seq, variance, signals_aligned)
           
        # hand geometry
        # CAUTION: We just calculated the arithmetic mean of the hand geometry
        # vector from the template building signals.
        if use_handgeo:
            
            assert (signal_t.handgeo is not None), 'Error in constructing ' \
                + 'hand geometry features of the template: ' \
                + 'handgeo of the signal is missing.'
            
            handgeo = signal_t.handgeo.copy()
            handgeo_std = signal_t.handgeo_std.copy()
            for signal in signals:
                
                if signal == signal_t:
                    
                    continue

                assert (signal.handgeo is not None), 'Error in constructing ' \
                    + 'hand geometry features of the template: ' \
                    + 'handgeo of the signal is missing.'
    
                handgeo += signal.handgeo
                handgeo_std += signal.handgeo_std
            
            handgeo /= k
            handgeo_std /= k
        else:
            handgeo = None
            handgeo_std = None
        
        
        
        
        template.handgeo = handgeo
        template.handgeo_std = handgeo_std
        
        return template
    

    def save_to_file(self, fn, mode, use_stat, use_handgeo):
        '''
        General interface to dump the signal object to files.
        '''
        
        FMSignalTemplate.save_to_file(self, fn, mode, use_stat)
        
        if use_handgeo:            
            self.save_handgeo(fn, mode)
            
    
    
    def load_from_file(self, fn, mode, use_stat, use_handgeo,
        user_label='', id_label='', seq=0):
        '''
        General interface to dump the signal object to files.
        '''

        FMSignalTemplate.load_from_file(self, fn, mode, use_stat, user_label, id_label, seq)
        
        if use_handgeo:
            self.load_handgeo(fn, mode)
    
    @classmethod
    def construct_from_file(cls, fn, mode, use_stat, use_handgeo,
        user_label='', id_label='', seq=0):
        '''
        Factory method to build the signal by loading a file.
        '''
        
        template = cls()
        
        template.load_from_file(fn, mode, use_stat, use_handgeo, user_label, id_label, seq)

        return template


    # FMSignalTemplateLeap inherited the dump_handge() and load_handgeo() methods
    # from FMSignalLeap









class FMSignalTemplateGlove(FMSignalTemplate, FMSignalGlove):
    '''
    FMSignal signal template (data glove version).
    
    This class is derived from both FMSignalTemplate and FMSignalGlove.
        
    '''


    def __init__(self, length=-1, dimension=-1, ts=None, data=None,
            stat=None, user_label='', id_label='', seq=0,
            variance=None, signals_aligned=None):
        '''
        Default constructor.
        '''
        
        FMSignalTemplate.__init__(self, length, dimension, ts, data,
            stat=stat, user_label=user_label, id_label=id_label, seq=seq,
            variance=variance, signals_aligned=signals_aligned)

        FMSignalGlove.__init__(self, length, dimension, ts, data,
            stat=stat, user_label=user_label, id_label=id_label, seq=seq)



    @classmethod
    def construct_from_signals(cls, signals, template_index, use_stat,
            window=50, penalty=0):
        '''
        Factory method to construct the template by aligning and average a set
        of signals.
        '''
        
        signal_t = signals[template_index]
        l = signal_t.l
        d = signal_t.d
        
        tup = FMSignalTemplate.prepare_construction_from_signals(signals, 
            template_index, use_stat, window, penalty)
        (ts, data, variance, stat, signals_aligned) = tup
        
        template = cls(l, d, ts, data, stat,
           signal_t.user_label, signal_t.id_label, signal_t.seq,
           variance, signals_aligned)


        return template


    @classmethod
    def construct_from_file(cls, fn, mode, use_stat, 
        user_label='', id_label='', seq=0):
        '''
        Factory method to build the signal by loading a file.
        '''
        
        template = cls()
        
        template.load_from_file(fn, mode, use_stat, user_label, id_label, seq)

        return template

    # FMSignalTemplateGlove inherited dump / load methods from FMSignalTemplate












































